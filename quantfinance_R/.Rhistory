portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "ROI", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
tickers <- c("SMH", "IBB", "XLY", "VNQ", "XLC", "TSM", "PFE", "GMAB", "EDR", "CMCSA", "HMC", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'daily', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=.99, max_sum=1.01) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=.01, max=.99) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "ROI", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
#visualize how our portfolio did over time
tickers <- c("SMH", "IBB", "XLY", "VNQ", "XLC", "TSM", "PFE", "GMAB", "EDR", "CMCSA", "HMC", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'daily', auto.assign=FALSE)[,4])
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
portf <- add.constraint(portf, type="weight_sum", min_sum=0.99, max_sum=1.01) #relaxed
portf <- add.constraint(portf, type="box", min=.01, max=.99)
portf <- add.objective(portf, type="return", name="mean")
portf <- add.objective(portf, type="risk", name="StdDev")
rp <- random_portfolios(portf, 10000, "sample") #new method. #10,000 random portfolios, pass into optimization function
opt_rebal <- optimize.portfolio.rebalancing(portfolioReturns,
portf,
optimize_method="random",
rp=rp,
rebalance_on="months",
training_period=1,
rolling_window=10)
#could change this (reblanace once every 10 months)
equal_weight <- rep(1 / ncol(portfolioReturns), ncol(portfolioReturns)) #benchmark
benchmark <- Return.portfolio(portfolioReturns, weights = equal_weight)
colnames(benchmark) <- "Benchmark Portfolio"
sp500prices <- getSymbols.yahoo("SPY", from='2016-01-03', periodicity = 'daily', auto.assign=FALSE)[,4]
sp500Rets <- na.omit(ROC(sp500prices))
sp500Rets <- as.xts(sp500Rets)
chart.Weights(opt_rebal, main="Rebalanced Weights Over Time")
rebal_weights <-extractWeights(opt_rebal) #give us the actual weights
rebal_returns <- Return.portfolio(portfolioReturns, weights=rebal_weights) #returns objects with the wieghts
rets_df <- cbind(rebal_returns, benchmark, sp500Rets)
#performance summary
charts.PerformanceSummary(rets_df, main="P/L Over Time") #perfromance over time
tickers <- c("SMH", "IBB", "XLY", "VNQ", "XLC", "TSM", "PFE", "GMAB", "EDR", "CMCSA", "HMC", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'daily', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=.99, max_sum=1.01) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0, max=1) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "ROI", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
tickers <- c("SMH", "IBB", "XLY", "VNQ", "XLC", "TSM", "PFE", "GMAB", "EDR", "CMCSA", "HMC", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'daily', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=.99, max_sum=1.01) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0.01, max=.99) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "ROI", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
tickers <- c("SMH", "IBB", "XLY", "VNQ", "XLC", "EDR", "CMCSA", "HMC", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'daily', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=1, max_sum=1) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0.10, max=.40) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "ROI", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
tickers <- c("SMH", "IBB", "XLY", "VNQ", "XLC", "EDR", "CMCSA", "HMC", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'daily', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=1, max_sum=1) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0.01, max=.99) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "ROI", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
tickers <- c("TSM", "PFE", "CMCSA", "HMC", "GMAB", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'daily', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=1, max_sum=1) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0.01, max=.99) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "ROI", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
?optimize.portfolio
tickers <- c("TSM", "PFE", "CMCSA", "HMC", "GMAB", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'daily', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=1, max_sum=1) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0.01, max=.99) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "random", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'monthly', auto.assign=FALSE)[,4]) #could change this
tickers <- c("TSM", "PFE", "CMCSA", "HMC", "GMAB", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'monthly', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=1, max_sum=1) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0.01, max=.99) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "random", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
tickers <- c("TSM", "PFE", "CMCSA", "HMC", "GMAB", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'yearly', auto.assign=FALSE)[,4]) #could change this
}
tickers <- c("TSM", "PFE", "CMCSA", "HMC", "GMAB", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'annually', auto.assign=FALSE)[,4]) #could change this
}
tickers <- c("TSM", "PFE", "CMCSA", "HMC", "GMAB", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'monthly', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=1, max_sum=1) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0.01, max=.99) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "random", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
tickers <- c("TSM", "PFE", "CMCSA", "HMC", "GMAB", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'monthly', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=.99, max_sum=1.01) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0.01, max=.99) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "random", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
optPort
#visualize how our portfolio did over time
tickers <- c("TSM", "PFE", "CMCSA", "HMC", "GMAB", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'monthly', auto.assign=FALSE)[,4])
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
portf <- add.constraint(portf, type="weight_sum", min_sum=0.99, max_sum=1.01) #relaxed
portf <- add.constraint(portf, type="box", min=.01, max=.99)
portf <- add.objective(portf, type="return", name="mean")
portf <- add.objective(portf, type="risk", name="StdDev")
rp <- random_portfolios(portf, 10000, "sample") #new method. #10,000 random portfolios, pass into optimization function
opt_rebal <- optimize.portfolio.rebalancing(portfolioReturns,
portf,
optimize_method="random",
rp=rp,
rebalance_on="months",
training_period=1,
rolling_window=10)
#could change this (reblanace once every 10 months)
equal_weight <- rep(1 / ncol(portfolioReturns), ncol(portfolioReturns)) #benchmark
benchmark <- Return.portfolio(portfolioReturns, weights = equal_weight)
colnames(benchmark) <- "Benchmark Portfolio"
sp500prices <- getSymbols.yahoo("SPY", from='2016-01-03', periodicity = 'daily', auto.assign=FALSE)[,4]
sp500Rets <- na.omit(ROC(sp500prices))
sp500Rets <- as.xts(sp500Rets)
chart.Weights(opt_rebal, main="Rebalanced Weights Over Time")
rebal_weights <-extractWeights(opt_rebal) #give us the actual weights
rebal_returns <- Return.portfolio(portfolioReturns, weights=rebal_weights) #returns objects with the wieghts
rets_df <- cbind(rebal_returns, benchmark, sp500Rets)
#performance summary
charts.PerformanceSummary(rets_df, main="P/L Over Time") #perfromance over time
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
```
tickers <- c("TSM", "PFE", "CMCSA", "HMC", "GMAB", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'monthly', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=.99, max_sum=1.01) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0.01, max=.99) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "random", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 500, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
optPort
tickers <- c("TSM", "PFE", "CMCSA", "HMC", "GMAB", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'monthly', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=.99, max_sum=1.01) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0.01, max=.99) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "random", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
knitr::opts_chunk$set(echo = TRUE)
library(quantmod)
library(PerformanceAnalytics)
library(PortfolioAnalytics)
library(foreach)
library(DEoptim)
library(iterators)
library(fGarch)
library(Rglpk)
library(quadprog)
library(ROI)
library(ROI.plugin.glpk)
library(ROI.plugin.quadprog)
library(ROI.plugin.symphony)
library(pso)
library(GenSA)
library(corpcor)
library(testthat)
library(nloptr)
library(MASS)
library(robustbase)
tickers <- c("TSM", "PFE", "CMCSA", "HMC", "GMAB", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'monthly', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=.99, max_sum=1.01) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0.01, max=.99) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "random", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
optPort
tickers <- c("TSM", "PFE", "CMCSA", "HMC", "GMAB", "NKE", "PSA", "DLR")
portfolioPrices <- NULL
for(ticker in tickers) {
portfolioPrices <- cbind(portfolioPrices,
getSymbols.yahoo(ticker, from='2013-01-03', periodicity = 'monthly', auto.assign=FALSE)[,4]) #could change this
}
portfolioReturns <- na.omit(ROC(portfolioPrices))
portf <- portfolio.spec(colnames(portfolioReturns))
#objectvies and constraints
portf <- add.constraint(portf, type="weight_sum", min_sum=1, max_sum=1.) #long-only, no shorts
portf <- add.constraint(portf, type="box", min=0.01, max=.99) #each indiv asset canot be less thatn 10% and cannot exeed 40%
#max return, min risk, no givens
portf <- add.objective(portf, type="return", name="mean") #max return = mean
portf <- add.objective(portf, type="risk", name="StdDev") #min isk  = stdDev
#simple solver
optPort <- optimize.portfolio(portfolioReturns, portf, optimize_method = "random", trace=TRUE)
#visualize weights of THE optimal portfolio
#optimally allocated weights to match our objective: max return, min risk
chart.Weights(optPort)
#visualize in a efficient frontier
ef <- extractEfficientFrontier(optPort, match.col = "StdDev", n.portfolios = 25,
risk_aversion = NULL)
chart.EfficientFrontier(ef,
match.col = "StdDev", n.portfolios = 25, xlim = NULL, ylim = NULL,
cex.axis = 0.8, element.color = "darkgray", main = "Efficient Frontier",
RAR.text = "SR", rf = 0, tangent.line = TRUE, cex.legend = 0.8,
chart.assets = TRUE, labels.assets = TRUE, pch.assets = 21,
cex.assets = 0.8)
optPort
